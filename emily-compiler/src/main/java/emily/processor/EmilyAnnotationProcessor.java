package emily.processor;

import android.content.Context;
import android.content.SharedPreferences;

import com.google.auto.service.AutoService;
import com.google.gson.reflect.TypeToken;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import javax.annotation.Generated;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.NoType;
import javax.lang.model.type.TypeMirror;

import emily.LocalStorage;
import emily.Named;
import emily.serializer.Serializer;

import static java.util.Collections.singleton;
import static javax.lang.model.SourceVersion.latestSupported;

@AutoService(Processor.class)
public class EmilyAnnotationProcessor extends AbstractProcessor {
    public static final String GENERATED_PREFIX = "Emily";

    private List<String> fields = new ArrayList<>();

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return singleton(LocalStorage.class.getCanonicalName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return latestSupported();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(LocalStorage.class)) {
            System.out.println("Generating code for: " + annotatedElement.getSimpleName());

            // Our annotation is defined with @Target(value=TYPE). Therefore, we can assume that
            // this annotatedElement is a TypeElement.
            TypeElement annotatedClass = (TypeElement) annotatedElement;
            if (!annotatedClass.getKind().isInterface()) {
                throw new IllegalArgumentException("Class annotated with LocalStorage must be an interface: " + annotatedClass.getSimpleName().toString());
            }

            LocalStorage localStorage = annotatedClass.getAnnotation(LocalStorage.class);

            if (!localStorage.cached() && localStorage.preFetch()) {
                throw new IllegalArgumentException("Cannot set cached to false and preFetch to true at the same time. If you want to use prefetching, you need to enable caching as well. Error in: " + annotatedClass.getQualifiedName().toString());
            }

            TypeSpec.Builder generatedClassBuilder = TypeSpec.classBuilder(GENERATED_PREFIX + annotatedElement.getSimpleName())
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL).addSuperinterface(TypeName.get(annotatedClass.asType())).addAnnotation(AnnotationSpec.builder(Generated.class).addMember("value", "\"This class was generated by the Emily library, and should not be edited directly by developers.\"").build());

            FieldSpec contextVariable = FieldSpec.builder(Context.class, "context", Modifier.PRIVATE).build();
            FieldSpec sharedPrefVariable = FieldSpec.builder(SharedPreferences.class, "sharedPreferences", Modifier.PRIVATE).build();
            FieldSpec serializer = FieldSpec.builder(Serializer.class, "serializer", Modifier.PRIVATE).build();

            MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(Context.class, "context")
                    .addParameter(String.class, "sharedPrefName")
                    .addParameter(Serializer.class, "serializer")
                    .addStatement("this.context = context")
                    .addStatement("this.sharedPreferences = context.getApplicationContext().getSharedPreferences(sharedPrefName, Context.MODE_PRIVATE)")
                    .addStatement("this.serializer = serializer");

            MethodSpec getContext = MethodSpec.methodBuilder("getContext")
                    .addModifiers(Modifier.PUBLIC)
                    .returns(Context.class)
                    .addStatement("return context")
                    .build();

            MethodSpec getSharedPrefs = MethodSpec.methodBuilder("getSharedPreferences")
                    .addModifiers(Modifier.PUBLIC)
                    .returns(SharedPreferences.class)
                    .addStatement("return this.sharedPreferences")
                    .build();

            generatedClassBuilder.addField(contextVariable).addField(sharedPrefVariable).addField(serializer).addMethod(getSharedPrefs).addMethod(getContext);

            for (Element element : annotatedClass.getEnclosedElements()) {
                if (element instanceof ExecutableElement) {
                    ExecutableElement executableElement = ((ExecutableElement) element);
                    String methodName = executableElement.getSimpleName().toString();

                    String variableName = getNameFromMethod(executableElement);

                    if (variableName != null) {
                        TypeMirror typeMirror = getMethodType(executableElement);
                        TypeName typeName = TypeName.get(typeMirror);

                        if (!fields.contains(variableName)) {
                            fields.add(variableName);

                            if (!isSharedPrefPrimitive(typeName) && localStorage.cached()) {
                                FieldSpec var = FieldSpec.builder(typeName, variableName, Modifier.PRIVATE).build();
                                generatedClassBuilder.addField(var);
                            }
                        }

                        if (isElementGetter(executableElement)) {
                            generatedClassBuilder.addMethod(generateCodeForGetter(typeName, variableName, executableElement, localStorage.cached()));

                            if (localStorage.preFetch())
                                constructor.addStatement("this.$L = $L()", variableName, executableElement.getSimpleName());
                        } else if (isElementSetter(executableElement)) {
                            generatedClassBuilder.addMethod(generateCodeForSetter(typeName, variableName, executableElement, localStorage.cached()));
                        } else {
                            throw new IllegalArgumentException("Method " + methodName + " is not a getter nor a setter.");
                        }
                    }
                }
            }

            generatedClassBuilder.addMethod(constructor.build());
            JavaFile javaFile = JavaFile.builder("emily.generated", generatedClassBuilder.build())
                    .build();

            try {
                javaFile.writeTo(processingEnv.getFiler());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return true;
    }

    private TypeMirror getMethodType(ExecutableElement executableElement) {
        if (executableElement.getParameters().size() == 0) {
            // Getter
            if (executableElement.getReturnType() instanceof NoType) {
                throw new IllegalArgumentException("Zero-arg method must be a getter, but it doesn't return anything: " + executableElement.getSimpleName());
            } else {
                return executableElement.getReturnType();
            }
        } else if (executableElement.getParameters().size() == 1 && executableElement.getReturnType() instanceof NoType) {
            // Setter
            return executableElement.getParameters().get(0).asType();
        } else {
            throw new IllegalArgumentException("Setter methods cannot have more than one argument:" + executableElement.getSimpleName());
        }
    }

    private boolean isElementGetter(ExecutableElement executableElement) {
        return executableElement.getParameters().size() == 0 && !(executableElement.getReturnType() instanceof NoType);
    }

    private boolean isElementSetter(ExecutableElement executableElement) {
        return executableElement.getParameters().size() == 1 && executableElement.getReturnType() instanceof NoType;
    }

    private String getNameFromMethod(ExecutableElement executableElement) {
        Named namedAnnotation = executableElement.getAnnotation(Named.class);
        if (namedAnnotation != null)
            return namedAnnotation.value();

        if (executableElement.getSimpleName().toString().startsWith("get") || executableElement.getSimpleName().toString().startsWith("set"))
            return executableElement.getSimpleName().toString().substring(3).toLowerCase();

        if (executableElement.getSimpleName().toString().startsWith("is"))
            return executableElement.getSimpleName().toString().substring(2).toLowerCase();

        return null;
    }

    private MethodSpec generateCodeForSetter(TypeName typeName, String name, ExecutableElement executableElement, boolean cached) {
        MethodSpec.Builder setterBuilder = MethodSpec.methodBuilder(executableElement.getSimpleName().toString()).returns(TypeName.VOID)
                .addParameter(typeName, name, Modifier.FINAL)
                .addModifiers(Modifier.PUBLIC);

        if (cached && !isSharedPrefPrimitive(typeName)) {
            setterBuilder.addStatement("this.$L = $L", name, name);
        }

        if (typeName == TypeName.INT) {
            setterBuilder.addStatement("getSharedPreferences().edit().putInt($S, $L).apply()", name, name);
        } else if (typeName == TypeName.BOOLEAN) {
            setterBuilder.addStatement("getSharedPreferences().edit().putBoolean($S, $L).apply()", name, name);
        } else if (typeName == TypeName.FLOAT) {
            setterBuilder.addStatement("getSharedPreferences().edit().putFloat($S, $L).apply()", name, name);
        } else if (typeName == TypeName.LONG) {
            setterBuilder.addStatement("getSharedPreferences().edit().putLong($S, $L).apply()", name, name);
        } else if (typeName.toString().equals("java.lang.String")) {
            setterBuilder.addStatement("getSharedPreferences().edit().putString($S, $L).apply()", name, name);
        } else {
            setterBuilder.addStatement("String serialized = serializer.serialize($L)", name);
            setterBuilder.addStatement("getSharedPreferences().edit().putString($S, serialized).apply()", name);
        }

        return setterBuilder.build();
    }

    private MethodSpec generateCodeForGetter(TypeName typeName, String name, ExecutableElement executableElement, boolean cached) {
        MethodSpec.Builder getterBuilder = MethodSpec.methodBuilder(executableElement.getSimpleName().toString()).returns(TypeName.get(executableElement.getReturnType()))
                .addModifiers(Modifier.PUBLIC);


        if (typeName == TypeName.INT) {
            getterBuilder.addStatement("return getSharedPreferences().getInt($S, 0)", name);
        } else if (typeName == TypeName.FLOAT) {
            getterBuilder.addStatement("return getSharedPreferences().getFloat($S, 0.0f)", name);
        } else if (typeName == TypeName.BOOLEAN) {
            getterBuilder.addStatement("return getSharedPreferences().getBoolean($S, false)", name);
        } else if (typeName == TypeName.LONG) {
            getterBuilder.addStatement("return getSharedPreferences().getLong($S, 0L)", name);
        } else if (typeName.toString().equals("java.lang.String")) {
            getterBuilder.addStatement("return getSharedPreferences().getString($S, null)", name);
        } else {
            if (cached)
                getterBuilder.addStatement("if (this.$L != null) return this.$L", name, name);

            getterBuilder.addStatement("String serialized = getSharedPreferences().getString($S, null)", name);
            getterBuilder.addStatement("$L $L = null", typeName.toString(), name);
            getterBuilder.addStatement("if (serialized != null)\n" +
                    "$L = serializer.deserialize(serialized, new $T<$L>(){}.getType())", name, TypeToken.class, typeName.toString());
            getterBuilder.addStatement("return $L", name);
        }

        return getterBuilder.build();
    }

    private boolean isSharedPrefPrimitive(TypeName typeName) {
        return typeName == TypeName.INT || typeName == TypeName.FLOAT || typeName == TypeName.BOOLEAN || typeName == TypeName.LONG || (typeName.toString().equals("java.lang.String"));
    }
}